{"ast":null,"code":"// 基于axios封装，网络请求的函数\nimport axios from 'axios';\nimport { Message } from 'element-ui';\nimport store from '@/store';\nimport { UpdateTokenAPI } from '@/api';\nimport router from '@/router'; // axios.create()创建一个带配置项的自定义axios函数\n// myAxios请求的时候，地址baseURL+url，然后去请求服务器\n\nexport const myAxios = axios.create({\n  baseURL: 'http://big-event-vue-api-t.itheima.net'\n});\nexport const myAxiosNew = axios.create({\n  baseURL: 'https://b2de4f056142.akimitsu.top/'\n});\nexport const myAxiosNewFromYiYan = axios.create({\n  baseURL: 'https://v1.hitokoto.cn'\n}); // 定义请求拦截器--减少多余的代码量\n\nmyAxiosNew.interceptors.request.use(function (config) {\n  // 在请求前会触发一次\n  // 为请求头挂载Authorization字段\n  // 它返回给axios内源码，config配置对象（要请求后台的参数都在这个对象上）\n  // console.log(config)\n  // 登录界面和注册界面发起请求时不需要Authorization，且无token，当到首页前会获取token，且后续的请求会要Authorization\n  if (store.state.token) {\n    config.headers.Authorization = store.state.token;\n  }\n\n  return config;\n}, function (err) {\n  // 如果有异常报错，会直接进入这里\n  // 返回一个拒绝状态的Promise对象（axios留在原地的Promise对象状态就为失败结果为error变量值）\n  // 此函数类似catch函数()里的return\n  // 口诀：return 非Promise对象值，会作为成功的结果，返回给下一个Promise对象（axios留在原地）\n  // 口诀：return  Promise对象值，返回给下一个Promise对象\n  // Promise.reject()原地留下一个新的Promise对象（状态为失败），它是Promise的类方法reject()\n  return Promise.reject(err);\n  /**\r\n   * 等同于return new Promise((resolve,reject)=>{\r\n   * reject(error)\r\n   * })\r\n   */\n}); // 定义响应拦截器--针对登录失败和注册失败\n\nmyAxiosNew.interceptors.response.use(function (response) {\n  // 响应http状态码为2xx或3xx时触发成功的回调，形参中的“response”是“成功的结果”\n  // return到axios原地Promise对象，作为成功的结果\n  // console.log(response.request)\n  return response;\n}, async function (err) {\n  console.dir(err); // 登录失败的情况，提示\n\n  if (err.response.status === 401) {\n    if (!store.state.token) Message.error('登录失败');else {\n      // const newToken = await UpdateTokenAPI(this.$store.state.refresh)\n      // console.log(newToken)\n      Message.error('token已过期，正在为您更新');\n      const {\n        data: newToken\n      } = await UpdateTokenAPI(store.state.refresh);\n      console.log(newToken);\n      store.state.token = `Bearer ${newToken.access}`;\n      console.log(store.state.token); // Message.success('请重进该功能模块')\n\n      router.go(0);\n      window.location.reload();\n    }\n  } else if (err.response.status === 400) {\n    Message.error('表单提交有误!');\n  } // 响应状态码为4xx，5xx时触发失败的回调，形参中的error是“失败的结果”\n  // return到axios原地Promise对象，作为失败拒绝的状态（如果那边用try+catch或者catch捕获，\n  // 可以捕获到我们传递过去的这个err变量的值）\n\n\n  return Promise.reject(err);\n}); // 导出axios自定义函数\n// export default myAxios\n// export default myAxiosNew","map":{"version":3,"names":["axios","Message","store","UpdateTokenAPI","router","myAxios","create","baseURL","myAxiosNew","myAxiosNewFromYiYan","interceptors","request","use","config","state","token","headers","Authorization","err","Promise","reject","response","console","dir","status","error","data","newToken","refresh","log","access","go","window","location","reload"],"sources":["C:/Users/26421/Desktop/PTSFD/src/utils/request.js"],"sourcesContent":["// 基于axios封装，网络请求的函数\r\nimport axios from 'axios'\r\nimport { Message } from 'element-ui'\r\nimport store from '@/store'\r\nimport { UpdateTokenAPI } from '@/api'\r\nimport router from '@/router'\r\n// axios.create()创建一个带配置项的自定义axios函数\r\n// myAxios请求的时候，地址baseURL+url，然后去请求服务器\r\nexport const myAxios = axios.create({\r\n  baseURL: 'http://big-event-vue-api-t.itheima.net'\r\n})\r\nexport const myAxiosNew = axios.create({\r\n  baseURL: 'https://b2de4f056142.akimitsu.top/'\r\n})\r\nexport const myAxiosNewFromYiYan = axios.create({\r\n  baseURL: 'https://v1.hitokoto.cn'\r\n})\r\n\r\n// 定义请求拦截器--减少多余的代码量\r\nmyAxiosNew.interceptors.request.use(function (config) {\r\n  // 在请求前会触发一次\r\n  // 为请求头挂载Authorization字段\r\n  // 它返回给axios内源码，config配置对象（要请求后台的参数都在这个对象上）\r\n  // console.log(config)\r\n  // 登录界面和注册界面发起请求时不需要Authorization，且无token，当到首页前会获取token，且后续的请求会要Authorization\r\n  if (store.state.token) {\r\n    config.headers.Authorization = store.state.token\r\n  }\r\n\r\n  return config\r\n}, function (err) {\r\n  // 如果有异常报错，会直接进入这里\r\n  // 返回一个拒绝状态的Promise对象（axios留在原地的Promise对象状态就为失败结果为error变量值）\r\n  // 此函数类似catch函数()里的return\r\n  // 口诀：return 非Promise对象值，会作为成功的结果，返回给下一个Promise对象（axios留在原地）\r\n  // 口诀：return  Promise对象值，返回给下一个Promise对象\r\n  // Promise.reject()原地留下一个新的Promise对象（状态为失败），它是Promise的类方法reject()\r\n  return Promise.reject(err)\r\n  /**\r\n   * 等同于return new Promise((resolve,reject)=>{\r\n   * reject(error)\r\n   * })\r\n   */\r\n})\r\n\r\n// 定义响应拦截器--针对登录失败和注册失败\r\nmyAxiosNew.interceptors.response.use(function (response) {\r\n  // 响应http状态码为2xx或3xx时触发成功的回调，形参中的“response”是“成功的结果”\r\n  // return到axios原地Promise对象，作为成功的结果\r\n  // console.log(response.request)\r\n  return response\r\n}, async function (err) {\r\n  console.dir(err)\r\n  // 登录失败的情况，提示\r\n  if (err.response.status === 401) {\r\n    if (!store.state.token) Message.error('登录失败')\r\n    else {\r\n      // const newToken = await UpdateTokenAPI(this.$store.state.refresh)\r\n      // console.log(newToken)\r\n      Message.error('token已过期，正在为您更新')\r\n      const { data: newToken } = await UpdateTokenAPI(store.state.refresh)\r\n      console.log(newToken)\r\n      store.state.token = `Bearer ${newToken.access}`\r\n      console.log(store.state.token)\r\n      // Message.success('请重进该功能模块')\r\n      router.go(0)\r\n      window.location.reload()\r\n    }\r\n  } else if (err.response.status === 400) {\r\n    Message.error('表单提交有误!')\r\n  }\r\n  // 响应状态码为4xx，5xx时触发失败的回调，形参中的error是“失败的结果”\r\n  // return到axios原地Promise对象，作为失败拒绝的状态（如果那边用try+catch或者catch捕获，\r\n  // 可以捕获到我们传递过去的这个err变量的值）\r\n  return Promise.reject(err)\r\n}\r\n)\r\n// 导出axios自定义函数\r\n// export default myAxios\r\n// export default myAxiosNew\r\n"],"mappings":"AAAA;AACA,OAAOA,KAAP,MAAkB,OAAlB;AACA,SAASC,OAAT,QAAwB,YAAxB;AACA,OAAOC,KAAP,MAAkB,SAAlB;AACA,SAASC,cAAT,QAA+B,OAA/B;AACA,OAAOC,MAAP,MAAmB,UAAnB,C,CACA;AACA;;AACA,OAAO,MAAMC,OAAO,GAAGL,KAAK,CAACM,MAAN,CAAa;EAClCC,OAAO,EAAE;AADyB,CAAb,CAAhB;AAGP,OAAO,MAAMC,UAAU,GAAGR,KAAK,CAACM,MAAN,CAAa;EACrCC,OAAO,EAAE;AAD4B,CAAb,CAAnB;AAGP,OAAO,MAAME,mBAAmB,GAAGT,KAAK,CAACM,MAAN,CAAa;EAC9CC,OAAO,EAAE;AADqC,CAAb,CAA5B,C,CAIP;;AACAC,UAAU,CAACE,YAAX,CAAwBC,OAAxB,CAAgCC,GAAhC,CAAoC,UAAUC,MAAV,EAAkB;EACpD;EACA;EACA;EACA;EACA;EACA,IAAIX,KAAK,CAACY,KAAN,CAAYC,KAAhB,EAAuB;IACrBF,MAAM,CAACG,OAAP,CAAeC,aAAf,GAA+Bf,KAAK,CAACY,KAAN,CAAYC,KAA3C;EACD;;EAED,OAAOF,MAAP;AACD,CAXD,EAWG,UAAUK,GAAV,EAAe;EAChB;EACA;EACA;EACA;EACA;EACA;EACA,OAAOC,OAAO,CAACC,MAAR,CAAeF,GAAf,CAAP;EACA;AACF;AACA;AACA;AACA;AACC,CAxBD,E,CA0BA;;AACAV,UAAU,CAACE,YAAX,CAAwBW,QAAxB,CAAiCT,GAAjC,CAAqC,UAAUS,QAAV,EAAoB;EACvD;EACA;EACA;EACA,OAAOA,QAAP;AACD,CALD,EAKG,gBAAgBH,GAAhB,EAAqB;EACtBI,OAAO,CAACC,GAAR,CAAYL,GAAZ,EADsB,CAEtB;;EACA,IAAIA,GAAG,CAACG,QAAJ,CAAaG,MAAb,KAAwB,GAA5B,EAAiC;IAC/B,IAAI,CAACtB,KAAK,CAACY,KAAN,CAAYC,KAAjB,EAAwBd,OAAO,CAACwB,KAAR,CAAc,MAAd,EAAxB,KACK;MACH;MACA;MACAxB,OAAO,CAACwB,KAAR,CAAc,iBAAd;MACA,MAAM;QAAEC,IAAI,EAAEC;MAAR,IAAqB,MAAMxB,cAAc,CAACD,KAAK,CAACY,KAAN,CAAYc,OAAb,CAA/C;MACAN,OAAO,CAACO,GAAR,CAAYF,QAAZ;MACAzB,KAAK,CAACY,KAAN,CAAYC,KAAZ,GAAqB,UAASY,QAAQ,CAACG,MAAO,EAA9C;MACAR,OAAO,CAACO,GAAR,CAAY3B,KAAK,CAACY,KAAN,CAAYC,KAAxB,EAPG,CAQH;;MACAX,MAAM,CAAC2B,EAAP,CAAU,CAAV;MACAC,MAAM,CAACC,QAAP,CAAgBC,MAAhB;IACD;EACF,CAdD,MAcO,IAAIhB,GAAG,CAACG,QAAJ,CAAaG,MAAb,KAAwB,GAA5B,EAAiC;IACtCvB,OAAO,CAACwB,KAAR,CAAc,SAAd;EACD,CAnBqB,CAoBtB;EACA;EACA;;;EACA,OAAON,OAAO,CAACC,MAAR,CAAeF,GAAf,CAAP;AACD,CA7BD,E,CA+BA;AACA;AACA"},"metadata":{},"sourceType":"module"}